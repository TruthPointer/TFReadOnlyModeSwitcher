/*
 * 硬件修改TF卡的TWP(临时写保护或只读)模式
 * 创建: 202306 By Ming
*/

#include <SPI.h>
#include "Sd2CardV2.h"
#include <avr/pgmspace.h>
#include <Wire.h>

///////////////////////////////////////////////
//1、参量声明
///////////////////////////////////////////////
//1.1 SD卡
#define CARD_TWP_RW 0  //CSD的临时写保护状态：禁用
#define CARD_TWP_RO 1  //CSD的临时写保护状态：启用
Sd2CardV2 card;
u8 crctable[256];  //发送命令需要，在Sd2Card里不需要了，在cardCommand()里处理

//1.2 按钮
//Lock和Unlock 是分别针对只读模式的启用和禁用而言。
//(1) 如果结果用LED显示，则：绿色LED表示 Lock 的状态；蓝色LED表示 Unlock 的状态
//(2) 如果结果用OLED显示屏显示，则用文字来明确表示
#define BUTTON_CHECK_PIN 4   //Nano的管脚：D2，检查卡状态
#define BUTTON_LOCK_PIN 2    //Nano的管脚：D3，设置只读状态
#define BUTTON_UNLOCK_PIN 3  //Nano的管脚：D4，取消只读状态

//1.3 OLED显示屏
// T(0) F(1)
const unsigned char ASCII_1632[][32] PROGMEM = {
  { 0x00, 0xC0, 0x40, 0xC0, 0x40, 0x40, 0xC0, 0x00, 0x06, 0x01, 0x00, 0xFF, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x0C, 0x08, 0x00, 0x00 }, /*"T",0*/
  { 0x40, 0xC0, 0x40, 0x40, 0x40, 0x40, 0xC0, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xC0, 0x01, 0x06, 0x00, 0xFF, 0x01, 0x01, 0x01, 0x07, 0x00, 0x00, 0x08, 0x0F, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00 }, /*"F",1*/
};
// 当(0) 前(1) 状(2) 态(3) 启(4) 用(5) 取(6) 消(7) 只(8) 读(9) 写(10) 成(11) 功(12) 失(13) 败(14) 错(15) 误(16) ：(17) 初(18) 始(19) 化(20) 卡(21)
const unsigned char HZK_1632[][64] PROGMEM = {
  { 0x00, 0x00, 0x00, 0x60, 0x80, 0x00, 0x00, 0xFC, 0x18, 0x00, 0x00, 0xC0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x23, 0x20, 0x20, 0x3F, 0x20, 0x28, 0x26, 0x21, 0x20, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7F, 0x00, 0x00 }, /*"当",0*/
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xE0, 0x00, 0x00, 0xC0, 0x3C, 0x08, 0x00, 0x80, 0x80, 0x00, 0x00, 0x01, 0x01, 0xF1, 0x11, 0x11, 0xF1, 0x11, 0x01, 0xF1, 0x01, 0x01, 0xFD, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x42, 0x42, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x10, 0x7F, 0x00, 0x00, 0x03, 0x10, 0x30, 0x3F, 0x00, 0x00, 0x00 }, /*"前",1*/
  { 0x00, 0x00, 0x00, 0x00, 0xFC, 0x08, 0x00, 0x00, 0x00, 0xF8, 0x08, 0x10, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x01, 0x3E, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0xF0, 0x10, 0x10, 0x1F, 0x18, 0x00, 0x00, 0xE0, 0x18, 0x04, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x03, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x30, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x07, 0x3C, 0x10, 0x00 }, /*"状",2*/
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x08, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0xC1, 0xBD, 0x03, 0x07, 0x39, 0xC1, 0x81, 0x01, 0x01, 0x01, 0x00, 0x00, 0x08, 0x84, 0x02, 0x01, 0xE0, 0x00, 0x33, 0xCE, 0x00, 0x00, 0x01, 0xC3, 0x86, 0x02, 0x00, 0x00, 0x0C, 0x0F, 0x00, 0x00, 0x3F, 0x20, 0x20, 0x21, 0x20, 0x3F, 0x10, 0x00, 0x0F, 0x00, 0x00 }, /*"态",3*/
  { 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x84, 0x78, 0x80, 0x80, 0x80, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFE, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0E, 0x01, 0x00, 0x3F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3F, 0x00, 0x00, 0x00 }, /*"启",4*/
  { 0x00, 0x00, 0x00, 0xF0, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x10, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x08, 0x08, 0x08, 0x08, 0xFF, 0x08, 0x08, 0x08, 0x08, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1F, 0x08, 0x08, 0x08, 0x08, 0xFF, 0x08, 0x08, 0x08, 0x08, 0xFF, 0x00, 0x00, 0x00, 0x38, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x08, 0x10, 0x78, 0x0F, 0x00, 0x00 }, /*"用",5*/
  { 0x00, 0x10, 0xF0, 0x10, 0x10, 0x10, 0xF0, 0x98, 0x80, 0x80, 0x80, 0x80, 0x80, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x04, 0x04, 0x04, 0xFF, 0x00, 0x01, 0xFE, 0x00, 0x00, 0xFC, 0x03, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xC1, 0x41, 0x61, 0xFF, 0x20, 0x10, 0x01, 0xFE, 0xDE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x3F, 0x20, 0x18, 0x07, 0x00, 0x01, 0x07, 0x1C, 0x08, 0x00 }, /*"取",6*/
  { 0x00, 0x00, 0x08, 0x70, 0xC0, 0x00, 0x10, 0xE0, 0x80, 0x00, 0xF8, 0x00, 0xC0, 0x30, 0x00, 0x00, 0x00, 0x08, 0x70, 0x00, 0x80, 0x7E, 0x00, 0xF8, 0x09, 0x08, 0x0F, 0x0A, 0x09, 0xF8, 0x00, 0x00, 0x00, 0x40, 0x40, 0xF0, 0x0F, 0x00, 0x00, 0xFF, 0x21, 0x21, 0x21, 0x21, 0x21, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x10, 0x70, 0x1F, 0x00, 0x00 }, /*"消",7*/
  { 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE1, 0x39, 0x01, 0x01, 0x09, 0x31, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0F, 0x1C, 0x00, 0x00 }, /*"只",8*/
  { 0x00, 0x00, 0x10, 0xE0, 0x00, 0x00, 0x40, 0x40, 0x40, 0xFC, 0x40, 0x40, 0x60, 0x40, 0x00, 0x00, 0x00, 0x20, 0x20, 0xF0, 0x00, 0x08, 0x08, 0x28, 0xC8, 0x07, 0xE8, 0x08, 0x08, 0x34, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x40, 0x42, 0x5C, 0x41, 0x40, 0xFF, 0x40, 0x40, 0x60, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x06, 0x41, 0x40, 0x20, 0x18, 0x06, 0x03, 0x04, 0x18, 0x70, 0x00, 0x00 }, /*"读",9*/
  { 0x00, 0x00, 0xE0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x90, 0x78, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xF8, 0x0F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x87, 0x82, 0x82, 0x82, 0x82, 0xC2, 0xE2, 0x82, 0xF2, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x70, 0x1F, 0x00, 0x00, 0x00 }, /*"写",10*/
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x08, 0x00, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFE, 0x02, 0x02, 0x82, 0x02, 0x07, 0xFA, 0x02, 0x02, 0xC2, 0x63, 0x02, 0x00, 0x00, 0x00, 0xFE, 0x01, 0x01, 0x01, 0xFF, 0x01, 0x00, 0x0F, 0xF0, 0x78, 0x07, 0x00, 0x80, 0x00, 0x00, 0x38, 0x07, 0x00, 0x01, 0x06, 0x47, 0x30, 0x08, 0x06, 0x01, 0x07, 0x0C, 0x18, 0x3F, 0x00 }, /*"成",11*/
  { 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x08, 0xFF, 0x08, 0x08, 0xF4, 0x0C, 0x00, 0x00, 0x80, 0x80, 0xC0, 0x7F, 0x20, 0x20, 0x10, 0x80, 0x7E, 0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x40, 0x20, 0x10, 0x0C, 0x03, 0x00, 0x08, 0x10, 0x70, 0x1F, 0x00, 0x00 }, /*"功",12*/
  { 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xFC, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1F, 0x02, 0x02, 0x02, 0xFF, 0x02, 0x02, 0x02, 0x02, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0xE1, 0x1F, 0x07, 0x39, 0xC1, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x40, 0x20, 0x10, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x1C, 0x38, 0x10, 0x00 }, /*"失",13*/
  { 0x00, 0xF0, 0x20, 0x20, 0x20, 0x20, 0xF0, 0x00, 0x00, 0xFC, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xE0, 0x1E, 0xE3, 0x02, 0x02, 0xFE, 0x02, 0x03, 0x00, 0x00, 0x7F, 0x00, 0xFC, 0x23, 0x40, 0x8F, 0x00, 0x00, 0x07, 0xF8, 0xBE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x30, 0x0E, 0x01, 0x00, 0x00, 0x47, 0x20, 0x18, 0x06, 0x01, 0x03, 0x0C, 0x38, 0x30, 0x00 }, /*"败",14*/
  { 0x00, 0x00, 0x00, 0xF8, 0x00, 0x80, 0x00, 0x00, 0xF4, 0x08, 0x00, 0xF4, 0x08, 0x80, 0x00, 0x00, 0x00, 0x70, 0x2F, 0xE1, 0x21, 0x31, 0x40, 0x41, 0x7F, 0x41, 0x41, 0x7F, 0x41, 0x41, 0x61, 0x00, 0x00, 0x08, 0x08, 0xFF, 0x08, 0x0C, 0x08, 0x00, 0xFC, 0x84, 0x84, 0x84, 0xFC, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x0C, 0x02, 0x00, 0x00, 0x3F, 0x10, 0x10, 0x10, 0x13, 0x2C, 0x00, 0x00 }, /*"错",15*/
  { 0x00, 0x00, 0x08, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0x10, 0x10, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0xF0, 0x00, 0x00, 0xC0, 0x4F, 0x44, 0xC4, 0x44, 0x44, 0x4F, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xD0, 0x30, 0x10, 0x10, 0xFF, 0x70, 0x90, 0x10, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x40, 0x30, 0x08, 0x07, 0x00, 0x00, 0x03, 0x0C, 0x38, 0x10, 0x00 }, /*"误",16*/
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /*"：",17*/
  { 0x00, 0x00, 0x00, 0x04, 0x78, 0x80, 0x00, 0x40, 0x40, 0xC0, 0x40, 0x40, 0x40, 0x40, 0xC0, 0x00, 0x00, 0x01, 0x01, 0xC1, 0xF9, 0x07, 0xE1, 0x20, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x00, 0x00, 0x0C, 0x03, 0x00, 0xFF, 0x07, 0x1C, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x20, 0x18, 0x06, 0x01, 0x00, 0x08, 0x10, 0x30, 0x1F, 0x00, 0x00 }, /*"初",18*/
  { 0x00, 0x00, 0x00, 0xF0, 0x18, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xF4, 0x0F, 0x04, 0xE4, 0x1E, 0x30, 0x6E, 0x21, 0x20, 0x20, 0x11, 0x1E, 0x78, 0x00, 0x00, 0x10, 0x2F, 0x60, 0xE0, 0x9F, 0x00, 0x00, 0xFC, 0x04, 0x04, 0x04, 0x04, 0xFE, 0x00, 0x00, 0x00, 0x20, 0x18, 0x06, 0x01, 0x01, 0x0F, 0x00, 0x3F, 0x08, 0x08, 0x08, 0x08, 0x3F, 0x00, 0x00 }, /*"始",19*/
  { 0x00, 0x00, 0x00, 0x00, 0xF0, 0x08, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFE, 0x09, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x30, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0xFF, 0x00, 0x40, 0x20, 0x18, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x30, 0x30, 0x30, 0x30, 0x1F, 0x00 }, /*"化",20*/
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x80, 0x80, 0x80, 0x80, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xFF, 0x40, 0x40, 0x40, 0x40, 0x40, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x08, 0x08, 0x10, 0x70, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, /*"卡",21*/
};
//不同消息的字符组合
const u8 MSG_CARD_INIT_SUCC[] = { 21, 18, 19, 20, 11, 12 };   //初始化成功
const u8 MSG_CARD_INIT_ERROR[] = { 21, 18, 19, 20, 13, 14 };  //初始化错误
const u8 MSG_CHECK_STATUS_PWM[] = { 0, 1, 2, 3, 17, 8, 9 };
const u8 MSG_CHECK_STATUS_NON_PWM[] = { 0, 1, 2, 3, 17, 9, 10 };
const u8 MSG_CHECK_STATUS_ERROR[] = { 0, 1, 2, 3, 17, 15, 16 };
const u8 MSG_SET_PWM_SUCC[] = { 4, 5, 8, 9, 17, 11, 12 };
const u8 MSG_SET_PWM_FAIL[] = { 4, 5, 8, 9, 17, 13, 14 };
const u8 MSG_CLEAR_PWM_SUCC[] = { 6, 7, 8, 9, 17, 11, 12 };
const u8 MSG_CLEAR_PWM_FAIL[] = { 6, 7, 8, 9, 17, 13, 14 };
//运行过程中的消息命令ID
#define SHOW_MSG_CARD_INIT_SUCC 0
#define SHOW_MSG_CARD_INIT_ERROR 1
#define SHOW_MSG_CHECK_STATUS_PWM 2
#define SHOW_MSG_CHECK_STATUS_NON_PWM 3
#define SHOW_MSG_CHECK_STATUS_ERROR 4
#define SHOW_MSG_SET_PWM_SUCC 5
#define SHOW_MSG_SET_PWM_FAIL 6
#define SHOW_MSG_CLEAR_PWM_SUCC 7
#define SHOW_MSG_CLEAR_PWM_FAIL 8
//OLDE的指令
#define OLED_CMD 0   //写命令
#define OLED_DATA 1  //写数据

//1.3 用于生成CSD的crc
#define CRC7_POLY 0x89

///////////////////////////////////////////////
//1、主程序
///////////////////////////////////////////////
void setup() {
  //1.初始化串口，用于debug
  Serial.begin(9600);
  while (!Serial) {
    ;  // wait for serial port to connect. Needed for native USB port only
  }
  Serial.println("初始化程序...");

  //2.初始化
  //2.1
  initOLED();
  setOLEDColorTurn(0);    //0正常显示 1反色显示
  setOLEDDisplayTurn(0);  //0正常显示 1翻转180度显示
  clearOLED();
  //2.2
  initButtonPin();

  //3.生成crcTable
  generateCRCTable();
  //showIntArray(crctable, 256);

  //4.初次尝试初始化和检查卡状态
  checkCardState();
}

void loop() {
  processButtonEvent();
}

///////////////////////////////////////////////
//2、读卡器部分
///////////////////////////////////////////////
/*
* 通过 utility libraries 初始化SD卡，且 Arduino Nano（ATmega328P）默认使用 D10 为读卡器的CS。
*/
u8 initCard() {
  Serial.println("\n初始化 SD 卡...");

  if (!card.init(SPI_HALF_SPEED)) {  //card.init(SPI_HALF_SPEED, chipSelect)，其中 chipSelect = 10
    Serial.println("初始化 SD 卡失败。请检查：");
    Serial.println("* 是否已插入卡？");
    Serial.println("* 接线是否正确？");
    Serial.println("* 检查读卡器片选（CS）引脚是否连接 Arduino Nano 的引脚 D10 ？");
    Serial.println("提示：按下Nano的Reset按钮从新运行程序。");
    showMessage(SHOW_MSG_CARD_INIT_ERROR);
    return false;
  }
  Serial.println("接线正确，且卡已插入。");
  showMessage(SHOW_MSG_CARD_INIT_SUCC);
  delay(500);
  return true;
}

//设置卡的只读TWP状态: 1: 只读状态; 0: 读写状态
void setTWPState(u8 readOnlyState) {
  char buff[80];
  csd_t csdt;
  u8 r = card.readCSD(&csdt);
  showInt(buff, "%-20s%d", "readCSD = ", r);
  if (r) {
    showByte14OfCSD(buff, csdt);
    csdt.v1.tmp_write_protect = readOnlyState;
    csdt.v2.tmp_write_protect = readOnlyState;

    Serial.println("writeCSD...");
    r = card.writeCSD(&csdt, crctable);
    if (r) {
      r = card.readCSD(&csdt);
      showByte14OfCSD(buff, csdt);
      if (r) {
        Serial.println("[4]成功修改CSD");
        showTWPStateMsg(readOnlyState, r);
      } else {
        showTWPStateMsg(readOnlyState, r);
      }
    } else {
      showTWPStateMsg(readOnlyState, r);
    }
  } else {
    showTWPStateMsg(readOnlyState, r);
  }
}

void showTWPStateMsg(u8 readOnlyState, u8 isSucc) {
  if (readOnlyState) {
    if (isSucc)
      showMessage(SHOW_MSG_SET_PWM_SUCC);
    else
      showMessage(SHOW_MSG_SET_PWM_FAIL);
  } else {
    if (isSucc)
      showMessage(SHOW_MSG_CLEAR_PWM_SUCC);
    else
      showMessage(SHOW_MSG_CLEAR_PWM_FAIL);
  }
}

void showByte14OfCSD(char buff[], csd_t csdt) {
  Serial.println("\r\nshowByte14OfCSD...");
  u8* dst = card.reinterpretCastToUint8ArrayPoint2(&csdt);
  showInt(buff, "%-20s%d", "CSD[14] = ", dst[14]);
}

///////////////////////////////////////////////
//3、按钮部分
void initButtonPin() {
  pinMode(BUTTON_CHECK_PIN, INPUT_PULLUP);
  pinMode(BUTTON_LOCK_PIN, INPUT_PULLUP);
  pinMode(BUTTON_UNLOCK_PIN, INPUT_PULLUP);
}

//检测buttonPin对应按钮是否被按下
bool findButtonPressed(u8 buttonPin) {
  if (digitalRead(buttonPin) == LOW) {
    delay(80);
    if (digitalRead(buttonPin) == LOW) {
      return true;
    }
  } else {
    return false;
  }
}

//处理按钮消息
void processButtonEvent() {
  if (findButtonPressed(BUTTON_CHECK_PIN)) {
    Serial.println("按下了“查询只读模式状态”按钮...");
    checkCardState();
  }
  if (findButtonPressed(BUTTON_LOCK_PIN)) {
    Serial.println("按下了“启用只读模式”按钮...");
    clearOLED();

    if (!initCard())
      return;
    setTWPState(CARD_TWP_RO);
  }
  if (findButtonPressed(BUTTON_UNLOCK_PIN)) {
    Serial.println("按下了“禁用只读模式”按钮...");
    clearOLED();

    if (!initCard())
      return;
    setTWPState(CARD_TWP_RW);
  }
}

void checkCardState() {
  clearOLED();

  if (!initCard()) return;

  csd_t csdt;
  u8 r = card.readCSD(&csdt);
  if (!r) {
    showMessage(SHOW_MSG_CARD_INIT_ERROR);
    return;
  }
  showTWPState(csdt);
}

void showTWPOfCSD(csd_t ct) {
  showTWPOfCSDV1(ct.v1);
  showTWPOfCSDV2(ct.v2);
}

void showTWPOfCSDV1(csd1_t ct) {
  Serial.println("-----CSD_V1---------");
  char buff[80];
  showInt(buff, "%-20s%d", "ct1.tmp_write_protect = ", ct.tmp_write_protect);
  Serial.println("--------------");
}

void showTWPOfCSDV2(csd2_t ct) {
  Serial.println("-----CSD_V2---------");
  char buff[80];
  showInt(buff, "%-20s%d", "ct2.tmp_write_protect = ", ct.tmp_write_protect);
  Serial.println("--------------");
}

//显示csdt数据中只读(写保护TMP)状态
void showTWPState(csd_t csdt) {
  u8* dst = card.reinterpretCastToUint8ArrayPoint2(&csdt);
  if (dst[14] & 0x10) {
    Serial.println(" 当前只读模式状态：启用...");
    showMessage(SHOW_MSG_CHECK_STATUS_PWM);
  } else {
    Serial.println(" 当前只读模式状态：禁用...");
    showMessage(SHOW_MSG_CHECK_STATUS_NON_PWM);
  }
}

///////////////////////////////////////////////
//3、显示屏部分
///////////////////////////////////////////////
//OLED的初始化
void initOLED(void) {
  Wire.begin(0x3c);  // join i2c bus (address optional for master)
  delay(200);

  writeOneByteToOLED(0xAE, OLED_CMD); /*display off*/
  writeOneByteToOLED(0x00, OLED_CMD); /*set lower column address*/
  writeOneByteToOLED(0x10, OLED_CMD); /*set higher column address*/
  writeOneByteToOLED(0x00, OLED_CMD); /*set display start line*/
  writeOneByteToOLED(0xB0, OLED_CMD); /*set page address*/
  writeOneByteToOLED(0x81, OLED_CMD); /*contract control*/
  writeOneByteToOLED(0xff, OLED_CMD); /*128*/
  writeOneByteToOLED(0xA1, OLED_CMD); /*set segment remap*/
  writeOneByteToOLED(0xA6, OLED_CMD); /*normal / reverse*/
  writeOneByteToOLED(0xA8, OLED_CMD); /*multiplex ratio*/
  writeOneByteToOLED(0x1F, OLED_CMD); /*duty = 1/32*/
  writeOneByteToOLED(0xC8, OLED_CMD); /*Com scan direction*/
  writeOneByteToOLED(0xD3, OLED_CMD); /*set display offset*/
  writeOneByteToOLED(0x00, OLED_CMD);
  writeOneByteToOLED(0xD5, OLED_CMD); /*set osc division*/
  writeOneByteToOLED(0x80, OLED_CMD);
  writeOneByteToOLED(0xD9, OLED_CMD); /*set pre-charge period*/
  writeOneByteToOLED(0x1f, OLED_CMD);
  writeOneByteToOLED(0xDA, OLED_CMD); /*set COM pins*/
  writeOneByteToOLED(0x00, OLED_CMD);
  writeOneByteToOLED(0xdb, OLED_CMD); /*set vcomh*/
  writeOneByteToOLED(0x40, OLED_CMD);
  writeOneByteToOLED(0x8d, OLED_CMD); /*set charge pump enable*/
  writeOneByteToOLED(0x14, OLED_CMD);
  clearOLED();
  writeOneByteToOLED(0xAF, OLED_CMD); /*display ON*/
}

//反显函数
void setOLEDColorTurn(u8 i) {
  if (!i)
    writeOneByteToOLED(0xA6, OLED_CMD);  //正常显示
  else
    writeOneByteToOLED(0xA7, OLED_CMD);  //反色显示
}

//屏幕旋转180度
//屏幕旋转180度
void setOLEDDisplayTurn(u8 i) {
  if (i == 0) {
    writeOneByteToOLED(0xC8, OLED_CMD);  //正常显示
    writeOneByteToOLED(0xA1, OLED_CMD);
  }
  if (i == 1) {
    writeOneByteToOLED(0xC0, OLED_CMD);  //反转显示
    writeOneByteToOLED(0xA0, OLED_CMD);
  }
}

//开启OLED显示
void displayOnOLED(void) {
  writeOneByteToOLED(0X8D, OLED_CMD);  //SET DCDC命令
  writeOneByteToOLED(0X14, OLED_CMD);  //DCDC ON
  writeOneByteToOLED(0XAF, OLED_CMD);  //DISPLAY ON
}

//关闭OLED显示
void displayOffOLED(void) {
  writeOneByteToOLED(0X8D, OLED_CMD);  //SET DCDC命令
  writeOneByteToOLED(0X10, OLED_CMD);  //DCDC OFF
  writeOneByteToOLED(0XAE, OLED_CMD);  //DISPLAY OFF
}

//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!
void clearOLED(void) {
  u8 i, n;
  for (i = 0; i < 4; i++) {
    writeOneByteToOLED(0xb0 + i, OLED_CMD);  //设置页地址（0~7）
    writeOneByteToOLED(0x00, OLED_CMD);      //设置显示位置—列低地址
    writeOneByteToOLED(0x10, OLED_CMD);      //设置显示位置—列高地址
    for (n = 0; n < 128; n++) writeOneByteToOLED(0, OLED_DATA);
  }  //更新显示
}

//---------------------------------------------
//发送一个字节
//向SSD1306写入一个字节。
//mode:数据/命令标志 0,表示命令;1,表示数据;
void writeOneByteToOLED(u8 dat, u8 mode) {
  Wire.beginTransmission(0x3c);
  if (mode) {
    Wire.write(0x40);
  } else {
    Wire.write(0x00);
  }
  Wire.write(dat);         // sends one byte
  Wire.endTransmission();  // stop transmitting
}

//坐标设置
void setBytePosOfOLED(u8 x, u8 y) {
  writeOneByteToOLED(0xb0 + y, OLED_CMD);
  writeOneByteToOLED(((x & 0xf0) >> 4) | 0x10, OLED_CMD);
  writeOneByteToOLED((x & 0x0f), OLED_CMD);
}

/*
 * 在指定位置显示一个字符：ascii为8*32，汉字为16*32
 *x: 当前的OLED的屏幕其x轴位置取值范围为0~127
 *y: 当前的OLED的屏幕其y轴位置取值范围为0~63
 *sizex: 字符的宽
 *sizey: 字符的高
 *chars：指定显示用的字符串
 *rowId: 指定显示的字符，其在chars的行位置
 *colSize: 指定显示的字符，其在chars中的列数或组成该字的字节数
*/
void ShowChar(u8 x, u8 y, u8 sizex, u8 sizey, const unsigned char** chars, const u8 rowId, u8 colSize) {
  u8 temp;
  for (int j = 0; j < colSize; j++) {
    if (j % sizex == 0) setBytePosOfOLED(x, y++);
    temp = pgm_read_byte(((unsigned char*)chars + rowId * colSize + j));
    writeOneByteToOLED(temp, OLED_DATA);
  }
}

/* 
 * 显示提示信息 
 * 此处不能使用swith...case
*/
void showMessage(u8 msgId) {
  clearOLED();

  u8 size;
  if (msgId == SHOW_MSG_CARD_INIT_SUCC) {
    u8 pos = 0;
    for (u8 i = 0; i < 2; i++) {
      ShowChar(8 * i, 0, 8, 16, (unsigned char**)ASCII_1632, i, 32);
    }
    size = sizeof(MSG_CARD_INIT_SUCC) / sizeof(MSG_CARD_INIT_SUCC[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * (i + 1), 0, 16, 32, (unsigned char**)HZK_1632, MSG_CARD_INIT_SUCC[i], 64);
    }
  } else if (msgId == SHOW_MSG_CARD_INIT_ERROR) {
    u8 pos = 0;
    for (u8 i = 0; i < 2; i++) {
      ShowChar(8 * i, 0, 8, 16, (unsigned char**)ASCII_1632, i, 32);
    }
    size = sizeof(MSG_CARD_INIT_ERROR) / sizeof(MSG_CARD_INIT_ERROR[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * (i + 1), 0, 16, 32, (unsigned char**)HZK_1632, MSG_CARD_INIT_ERROR[i], 64);
    }
  } else if (msgId == SHOW_MSG_CHECK_STATUS_PWM) {
    size = sizeof(MSG_CHECK_STATUS_PWM) / sizeof(MSG_CHECK_STATUS_PWM[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_CHECK_STATUS_PWM[i], 64);
    }
  } else if (msgId == SHOW_MSG_CHECK_STATUS_NON_PWM) {
    size = sizeof(MSG_CHECK_STATUS_NON_PWM) / sizeof(MSG_CHECK_STATUS_NON_PWM[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_CHECK_STATUS_NON_PWM[i], 64);
    }
  } else if (msgId == SHOW_MSG_CHECK_STATUS_ERROR) {
    size = sizeof(MSG_CHECK_STATUS_ERROR) / sizeof(MSG_CHECK_STATUS_ERROR[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_CHECK_STATUS_ERROR[i], 64);
    }
  } else if (msgId == SHOW_MSG_SET_PWM_SUCC) {
    size = sizeof(MSG_SET_PWM_SUCC) / sizeof(MSG_SET_PWM_SUCC[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_SET_PWM_SUCC[i], 64);
    }
  } else if (msgId == SHOW_MSG_SET_PWM_FAIL) {
    size = sizeof(MSG_SET_PWM_FAIL) / sizeof(MSG_SET_PWM_FAIL[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_SET_PWM_FAIL[i], 64);
    }
  } else if (msgId == SHOW_MSG_CLEAR_PWM_SUCC) {
    size = sizeof(MSG_CLEAR_PWM_SUCC) / sizeof(MSG_CLEAR_PWM_SUCC[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_CLEAR_PWM_SUCC[i], 64);
    }
  } else if (msgId == SHOW_MSG_CLEAR_PWM_FAIL) {
    size = sizeof(MSG_CLEAR_PWM_FAIL) / sizeof(MSG_CLEAR_PWM_FAIL[0]);
    for (u8 i = 0; i < size; i++) {
      ShowChar(16 * i, 0, 16, 32, (unsigned char**)HZK_1632, MSG_CLEAR_PWM_FAIL[i], 64);
    }
  }
}

///////////////////////////////////////////////
//4、其它
///////////////////////////////////////////////
void generateCRCTable() {
  int i, j;
  // generate a table value for all 256 possible byte values
  for (i = 0; i < 256; i++) {
    crctable[i] = (i & 0x80) ? i ^ CRC7_POLY : i;
    for (j = 1; j < 8; j++) {
      crctable[i] <<= 1;
      if (crctable[i] & 0x80)
        crctable[i] ^= CRC7_POLY;
    }
  }
}

void showIntArray(u8 arr[], int arrSize) {
  Serial.println("数据为：");
  for (int i = 0; i < arrSize; i++) {
    Serial.print(arr[i], HEX);
    if (i > 0 && i < arrSize - 1) {
      Serial.print(", ");
    }
    if (i > 0 && i % 16 == 0) {
      Serial.println("");
    }
  }
  Serial.println("");
}

void showCharArray(char arr[], int arrSize) {
  //Serial.println("数据为：");
  for (int i = 0; i < arrSize; i++) {
    Serial.print(arr[i], HEX);
    if (i < arrSize - 1) {
      Serial.print(", ");
    }
    //if (i > 0 && i % 16 == 0) {
    //  Serial.println("");
    //}
  }
  //Serial.println("");
}

void showInt(char buff[], char* format, char* title, u8 param) {
  sprintf(buff, format, title, param);
  Serial.println(buff);
}

void showCharArray(char buff[], char* format, char* title, char* param) {
  sprintf(buff, format, title, param);
  Serial.println(buff);
}
